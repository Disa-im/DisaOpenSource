<#@ template language="C#" #>
<#@ import namespace="Annotations" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the SharpTL compiler (https://github.com/Taggersoft/SharpTL).
//     Generated at <#=DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable 1591

#region R#

// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable CollectionNeverUpdated.Global
// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable UnusedParameter.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable InconsistentNaming

#endregion

namespace <#=_templateVars.Namespace #>
{
    using SharpTL;
    using System.Threading.Tasks;
    using ProtoBuf;

    // TL constructors.

<#
    // Writing constructors with common types.
    WriteTLObjects(_templateVars.Schema.Constructors, _templateVars.Schema.TypesBox.Where(t => t.HasConstructors && !t.IsBuiltIn));

    // Writing constructors without common types, because this is methods.
    // Hence method constructor is actually bunch of args to a method, which knows how to serialize itself.
    WriteTLObjects(_templateVars.Schema.Methods, null, true);
#>

    // TL types.

<#
foreach (TLType type in from t in _templateVars.Schema.TypesBox where t.HasConstructors && !t.IsBuiltIn select t)
{
#>
    [TLType(<#=type.Constructors.Select(constructor => string.Format("typeof({0})", constructor.Name)).Aggregate((s, s1) => s + ", " + s1)
    #>)]
    [ProtoContract]
    <#
    foreach (var constructor in type.Constructors)
    {
    #>
    [ProtoInclude(<#=_templateVars.tag++#>,<#=string.Format("typeof({0})", constructor.Name)#>)]
    <#
    }
    #>
    public partial interface <#=type.Name #>
    {
    }

<#
}
#>

    /// <summary>
    ///     TL methods.
    /// </summary>
    public interface I<#=_templateVars.MethodsInterfaceName#>Methods
    {
<#
    foreach (TLCombinator method in _templateVars.Schema.Methods)
    {
#>
        <#=method.Type.Name #> <#=method.Name #>(<#=method.Name #>Args args);
<#
    }
#>
    }

    /// <summary>
    ///     TL async methods.
    /// </summary>
    public interface I<#=_templateVars.MethodsInterfaceName#>AsyncMethods
    {
<#
    foreach (TLCombinator method in _templateVars.Schema.Methods)
    {
        string returnType = method.Type.IsVoid ? "Task" : String.Format("Task<{0}>", method.Type.Name);
#>
        <#=returnType #> <#=method.Name #>Async(<#=method.Name #>Args args);
<#
    }
#>
    }
}
#pragma warning restore 1591
<#+[UsedImplicitly] private TemplateVars _templateVars; #>
<#+
private void WriteTLObjects(IEnumerable<TLCombinator> constructors, IEnumerable<TLType> types, bool isMethodsArgs = false)
{
    List<TLType> typesList = types != null ? types.ToList() : null;
    foreach (TLCombinator constructor in constructors)
    {
#>
    [TLObject(0x<#=constructor.Number.ToString("X8") #>)]
    [ProtoContract]
    public partial class <#=
    string.Format("{0}{1}", isMethodsArgs ? constructor.Name + "Args" : constructor.Name,
        (typesList != null && typesList.Contains(constructor.Type)) ? " : " + constructor.Type.Name : String.Empty)
    #>
    {
<#+
        int i = 0;
        foreach (TLCombinatorParameter parameter in constructor.Parameters)
        {
            TLSerializationMode? serModeOverride = parameter.Type.SerializationModeOverride;
#>

<#+
		if(!parameter.IsFlag)
		{
#>
			[ProtoMember(<#=++i #>)]
        	[TLProperty(<#=i #><#=serModeOverride.HasValue ? string.Format(", TLSerializationMode.{0}", serModeOverride.Value) : String.Empty #>)]
        	public <#=parameter.Type.Name #> <#= parameter.Name #> { get; set; }
<#+
		}
		else
		{
#>
			[ProtoMember(<#=++i #>)]
			[TLProperty(<#=i #>,<#=parameter.FlagIndex#>,true<#=serModeOverride.HasValue ? string.Format(", TLSerializationMode.{0}", serModeOverride.Value) : String.Empty #>)]
        	public <#=parameter.Type.Name #> <#= parameter.Name #> { get; set; }
<#+
		}
#>

<#+
        }
#>
    }

<#+
    }
}
#>
