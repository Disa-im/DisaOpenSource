<#@ template language="C#" #>
<#@ import namespace="Annotations" #>

// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the SharpTL compiler (https://github.com/Taggersoft/SharpTL).
//     Generated at <#=DateTime.Now #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable 1591
// ReSharper disable UnusedMember.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable InconsistentNaming
namespace <#=_templateVars.Namespace #>
{
    using System.Threading.Tasks;
    using IRemoteProcedureCaller = SharpMTProto.IRemoteProcedureCaller;

    public partial class <#=_templateVars.MethodsInterfaceName#>AsyncMethods : I<#=_templateVars.MethodsInterfaceName#>AsyncMethods
    {
        private readonly IRemoteProcedureCaller _remoteProcedureCaller;

        public <#=_templateVars.MethodsInterfaceName#>AsyncMethods(IRemoteProcedureCaller remoteProcedureCaller)
        {
            _remoteProcedureCaller = remoteProcedureCaller;
            SetupRemoteProcedureCaller(remoteProcedureCaller);
        }

        partial void SetupRemoteProcedureCaller(IRemoteProcedureCaller remoteProcedureCaller);

<#
    foreach (TLCombinator method in _templateVars.Schema.Methods)
    {
        string returnType = method.Type.IsVoid ? "Task" : String.Format("Task<{0}>", method.Type.Name);
#>
        public <#=returnType #> <#=method.Name #>Async(<#=method.Name #>Args args)
        {
            <#=method.Type.IsVoid ? "return _remoteProcedureCaller.SendAsync(args);" : String.Format("return _remoteProcedureCaller.RpcAsync<{0}>(args);", method.Type.Name)#>
        }

<#
    }
#>
    }
}
#pragma warning restore 1591
<#+[UsedImplicitly] private TemplateVars _templateVars;#>
